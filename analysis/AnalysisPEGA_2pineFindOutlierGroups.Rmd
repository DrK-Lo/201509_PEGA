---
title: "PEGA for Pine Analysis: Step 2 choose outlier groups"
author: "Katie Lotterhos"
date: "April 24, 2016"
output: html_document
---

### Load data
setwd("/Users/katie/Desktop/CurrResearch/1-AdaptreeData/201509_PEGA/analysis/")
```{r, label="load data"}
load("../data/large_files/Pine_Alpha_AveRho_WithSuperLogical.RData")
  #if(!("ash" %in% installed.packages())){install.packages("ash")}
  require(ash)
  require(fields)
  require(dplyr)
```
This loads:

* PE
* results_pine3
* gtcontig_array 
* gtcontig_array_names
* PE_matchGWAS
* PE_matchGEA

### Plotting function plot_2D.b
plot_2D.b does not flip the phenotype axis.  Instead it colors the quadrant for the expected direction based on the PE association
```{r}
plot_2D.b <- function(x,y, xlab, ylab, xlim=c(-0.3,0.3), ylim=c(-0.3,0.3), nbin, x_sub, y_sub, x_sub_green=NULL, y_sub_green=NULL, x_sub_blue=NULL,  y_sub_blue=NULL,x_sub_golden=NULL,y_sub_golden=NULL, PE=1){
  #if(PE<0){x <- -x; x_sub <- -x_sub}

  data1 <- cbind(x, y)
  data1b <- data1[complete.cases(data1),]
  if(length(xlim)==0){
    xlim_up <- max(x, na.rm=TRUE)+0.15*max(x, na.rm=TRUE)
    xlim_lower <- min(x, na.rm=TRUE)-0.15*max(x, na.rm=TRUE)
  }else{
    xlim_lower <- xlim[1]; xlim_up <- xlim[2]
  }
  if(length(ylim)==0){
    ylim_up <- max(y, na.rm=TRUE)+0.15*max(y, na.rm=TRUE)
    ylim_lower <- min(y, na.rm=TRUE)-0.15*max(y, na.rm=TRUE)
  }else{
    ylim_lower <- ylim[1]; ylim_up <- ylim[2]
  }
        binned <- bin2(data1b,
                 matrix(c(xlim_lower,xlim_up,ylim_lower,ylim_up), 2,2, byrow=TRUE),
                 nbin=c(nbin,nbin))
    binned$nc[binned$nc==0]=NA
    image(seq(xlim_lower,xlim_up,length.out = nbin), 
               seq(ylim_lower,ylim_up, length.out=nbin),
               binned$nc,
             xlab=xlab, ylab=ylab, add=FALSE, 
             col=grey.colors(75, 0.25,0.9),
             xaxt="n", yaxt="n", bty="n")
    if(PE > 0.1){
      polygon(c(0,1,1,0,0), c(0,0,1,1,0),col=rgb(0,0,0,0.1))
      polygon(c(0,-1,-1,0,0), c(0,0,-1,-1,0), col=rgb(0,0,0,0.1))
      }
    if(PE < -0.1){
      polygon(c(0,-1,-1,0,0), c(0,0,1,1,0),col=rgb(0,0,0,0.1))
      polygon(c(0,1,1,0,0), c(0,0,-1,-1,0),col=rgb(0,0,0,0.1))
      }
    points(x_sub, y_sub, pch=24, cex=1, col="magenta", bg="orange")
    
    lines(c(-100,100), c(0,0), col="grey") #add x axis
    lines(c(0,0), c(-100,100), col="grey") # add y axis
    P <- 0.005 # cutoff for linear model significance
    if (abs(PE)>0.1){
      abline(lm(y~x), lwd=2)
      if(length(x_sub)>5){
        m <- lm(y_sub~x_sub)
        if(summary(m)$coef[2,4] < P){abline(m, col="orange", lwd=2)}
        }
      }
  
    if(length(x_sub_green)>0){
      points(x_sub_green, y_sub_green, pch=24, cex=1, col="darkgreen", bg="green")
      if (abs(PE)>0.1 & length(x_sub_green)>5){
        m <- lm(y_sub_green~x_sub_green)
        if(summary(m)$coef[2,4] < P){abline(m, col="green", lwd=2)}
      }
    }#end if x_sub_green
    if(length(x_sub_blue)>0){
      points(x_sub_blue, y_sub_blue, pch=24, cex=1, col="blue", bg="lightblue")
      if (abs(PE)>0.1 & length(x_sub_blue)>5){
        m <- lm(y_sub_blue~x_sub_blue)
        if(summary(m)$coef[2,4] < P){abline(m, col="blue", lwd=2)}
      }
    }#end if x_sub_blue
      if(length(x_sub_golden)>0){
      points(x_sub_golden, y_sub_golden, pch=24, cex=1, col="darkgoldenrod4", bg="darkgoldenrod")
      if (abs(PE)>0.1 & length(x_sub_golden)>5){
        m <- lm(y_sub_golden~x_sub_golden)
        if(summary(m)$coef[2,4] < P){abline(m, col="darkgoldenrod", lwd=2)}
      }
    }#end if x_sub_blue
    

    text(xlim_up*0.05, ylim_up*0.95, "+", cex=2, col="black")
    text(xlim_up*0.05, ylim_lower*0.95, "-", cex=2, col="black")
    
  text(xlim_up*0.95,ylim_up*0.05,"+", cex=2, col="black"); text(xlim_lower*0.95,ylim_up*0.05,"-", cex=2, col="black")

    text(xlim_up*0.75,ylim_lower*0.95, paste("PE =", PE), cex=1.2)
} # end plot_2D.b
```



### Plotting function for muliple panels, ordered by dendogram of covariances among phenotypes and environments

```{r}
head(PE)
load("../../20160125 heatmap denograms envi pheno/PineHeatmap.Rdata")
# loads env,env_clust,phen,phen_clust,EvP, EvPclust
  # env, phen, and EvP are correlation matrices based on raw data
  # env_clust and phen_clust are heatmap.2 objects showing how variables were ordered
names(env_clust)
(xorder <- rownames(env_clust$carpet)) # plotted in x axis in this order
colnames(env_clust$carpet) # plotted in y axis in this order

(yorder <- rev(rownames(phen_clust$carpet))) # plotted phenotypes in this order
#yorder <- yorder[-4] # remove root weight
pheno_ind <- c(1:3,5:17)
colnames(phen_clust$carpet) # plotted in y axis in this order

#### Function for plotting according to dendogram order
MakeOutlierPlot <- function(filename, Group_logical, envi_ind=1:22, pheno_ind=c(1:3,5:17), xlim=c(-0.3,0.3), ylim=c(-0.3,0.3),  width=50, height=66, type="Bayenv", Green_logical=NULL, Blue_logical=NULL, Golden_logical=NULL){
    #type = "Bayenv" or "Raw"
  
  pdf(file = filename,width=width,height=height)
  par(mfrow=c(length(envi_ind),length(pheno_ind)), mar=c(2,2,0,0), oma=c(6,6,6,0))
  for (i in envi_ind){ ## loop through environments
    for (j in pheno_ind){ ## loop through phenotypes
     
      ### y = get GEA column
      if(type=="Bayenv"){gea_col <- grep(paste("^",xorder[i],"_rhoave", sep=""),names(results_pine3))}
      if(type=="Raw"){gea_col <- grep(paste("^",xorder[i],"_raw_rho", sep=""),names(results_pine3))}
      
      y <- results_pine3[,gea_col] #carrot is needed for FFP
      
      ### x = get GPA column
        gpa1 <- PE_matchGWAS$Phenotype_GWAS[which(PE_matchGWAS$Abb == yorder[j])]
        if(gpa1=="root_wt__shoot_wt_p"){
          gpa1 <- "root_wt_shoot_wt_p"}
        if(gpa1=="root_wt__shoot_wt_p_1"){
          gpa1 <- "root_wt_shoot_wt_p_1"} 
        
        if(type=="Bayenv"){
          gpa2<- gsub("_p","",gpa1)
          gpa_col <- grep(paste("^",gpa2, "_rhoave_BAYENV", sep=""), names(results_pine3))
        }
        if(type=="Raw"){gpa_col <- grep(paste("^",gpa1,"_raw_rho", sep=""), names(results_pine3))}
  
      x <- results_pine3[,gpa_col]
    # pecorr = get PE
      pecorr <- PE$pine_correlation[(PE$Environment==PE_matchGEA$Environment_PE[PE_matchGEA$Environment_GEA == xorder[i]]) & PE$PhenAbb==yorder[j]]
      
      # make plot2D
      plot_2D.b(x,y, 
         xlab= "", xlim=xlim,
         ylab= "" , ylim=ylim,
         nbin=100, 
         x_sub=x[Group_logical], 
         y_sub=y[Group_logical],
         PE=pecorr,
         x_sub_green=x[Green_logical],
         y_sub_green=y[Green_logical],
         x_sub_blue=x[Blue_logical],
         y_sub_blue=y[Blue_logical],
         x_sub_golden=x[Golden_logical],
         y_sub_golden=y[Golden_logical]
         ) 
      mtext(xorder[i], side=2)
      mtext(yorder[j], side=1)
    } #end j loop
    print(i)
    } #end i loop
  dev.off()

}# end function
```

### Group 1: Top SNP's from Sam's top candidates

```{r,label="Top SNP's from Sam's top candidates" }
  superdf <- results_pine3[results_pine3$pine_super_p9 | 
                           results_pine3$pine_super_raw_p9,]
  names(results_pine3)[grep("raw_rho", names(results_pine3))]
  cols_raw <- grep("raw_rho", names(results_pine3))
  is.superdf <- matrix(NA, nrow(superdf), length(cols_raw))
  colnames(is.superdf) <- names(results_pine3)[cols_raw]
  tail <- 0.999
  for (i in 1:length(cols_raw)){
    a<- sort(abs(results_pine3[,cols_raw[i]]), na.last = NA)
    sorted.index <- round(length(a)*.999)
    rho_cutoff <- a[sorted.index]
    is.superdf[,i] <- abs(superdf[,cols_raw[i]])>rho_cutoff
    print(i)
  }
  num.var.raw.out <- rowSums(is.superdf,na.rm = TRUE)
  nrow(superdf) #total number of SNPs in super contigs
  sum(num.var.raw.out>0) # number of super SNPs in super contigs
  
#number gcontigs represented by all super vs. super SNPs
  length(unique(superdf$gtcontig)) # all Sam's super contigs
  length(unique(superdf$gtcontig[num.var.raw.out>0])) # super contigs with superSNPs

  ### Dataframe of Group 1
  Group1_allSuperSNPs <- superdf[num.var.raw.out>0,]
  dim(Group1_allSuperSNPs)
  ### Logical Group 1
  Group1_logical <- results_pine3$gcontig__gcontig_pos %in% Group1_allSuperSNPs$gcontig__gcontig_pos


  ### Group 1 array
  #png(file = "GroupEnvByPheno.png",width=50,height=66, unit="in", res=300)
  Group1_allSuperSNPs_array_names <- unique(Group1_allSuperSNPs$gtcontig)
  Group1_allSuperSNPs_array <- sapply(Group1_allSuperSNPs_array_names, getInd2, Group1_allSuperSNPs)
  
    ### snps per contig in top candidates
  G1_df <- data.frame(contig=Group1_allSuperSNPs_array_names,
             numOutSnps=as.numeric(sapply(Group1_allSuperSNPs_array, length)))
  dim(G1_df)
  G1_df <- G1_df[order(G1_df$numOutSnps, decreasing = TRUE),]
  G1_df$rank_numOut <- rank(1/G1_df$numOutSnps) 
    # index shows order by number of SNPs - contig with most outlier SNPs # 1
  G1_df$numTotSnps <- sapply(1:nrow(G1_df), function(i){sum(results_pine3$gtcontig==G1_df$contig[i])})
  G1_df$prop <- G1_df$numOutSnps/G1_df$numTotSnps
    # proportion of outlier SNPs in that contig
  
  ### Print top candidate list to html file, ordered by the contigs with the higest proportion of outliers SNPS
  G1_df$rank_prop <- rank(1/G1_df$prop)
  G1_df[order(G1_df$prop, decreasing=TRUE),]

   #topcan <- as.character(G1_df$contig[G1_df$prop>0.05])
   #length(topcan)
  
  ### Which ones are super convergent outliers
  results_pine3$gtcontig[Group1_logical & results_pine3$pine_super_convergent]

  names(results_pine3)
  results_pine3$Group1_logical <- Group1_logical
```


### Group 1 Make some comparison plots
```{r}

names(results_pine3)[grep("MAT", names(results_pine3))]

plot_2D.b(x=results_pine3$MAT_rhoave,
       y=results_pine3$MAP_rhoave, 
       xlab= "MAT rho Bayenv", 
       ylab= "MAP rho Bayenv" , 
       nbin=100, xlim=c(-0.3,0.3), ylim=c(-0.3,0.3),
       x_sub=results_pine3$MAT_rhoave[Group1_logical], 
       y_sub=results_pine3$MAP_rhoave[Group1_logical],
       PE=0.33)

plot_2D.b(x=results_pine3$MAT_raw_rho,
       y=results_pine3$MAP_raw_rho, 
       xlab= "MAT rho raw", 
       ylab= "MAP rho raw" , 
       nbin=100, xlim=c(-0.8,0.8), ylim=c(-0.8,0.8),
       x_sub=results_pine3$MAT_raw_rho[Group1_logical], 
       y_sub=results_pine3$MAP_raw_rho[Group1_logical],
       PE=0.33)

plot_2D.b(x=results_pine3$Fall_cold_injury_rhoave_BAYENV,
       y=results_pine3$LAT_rhoave, 
       xlab= "FCI rho Bayenv", 
       ylab= "LAT rho Bayenv" , 
       nbin=100, xlim=c(-0.3,0.3), ylim=c(-0.3,0.3),
       x_sub=superdf$Fall_cold_injury_rhoave_BAYENV[num.var.raw.out>0], 
       y_sub=superdf$LAT_rhoave[num.var.raw.out>0],
       PE=-0.42)

plot_2D.b(x=results_pine3$Fall_cold_injury_rhoave_BAYENV,
       y=results_pine3$MAP_rhoave, 
       xlab= "FCI rho Bayenv", 
       ylab= "LAT rho Bayenv" , 
       nbin=100, xlim=c(-0.3,0.3), ylim=c(-0.3,0.3),
       x_sub=superdf$Fall_cold_injury_rhoave_BAYENV[num.var.raw.out>0], 
       y_sub=superdf$MAP_rhoave[num.var.raw.out>0],
       PE=0.25)

plot_2D.b(x=results_pine3$Fall_cold_injury_p_raw_rho,
       y=results_pine3$MAP_raw_rho, 
       xlab= "FCI rho Bayenv", 
       ylab= "LAT rho Bayenv" , 
       nbin=100, xlim=c(-1,1), ylim=c(-1,1),
       x_sub=superdf$Fall_cold_injury_p_raw_rho[num.var.raw.out>0], 
       y_sub=superdf$MAP_raw_rho[num.var.raw.out>0],
       PE=0.25)

plot_2D.b(x=results_pine3$Fall_cold_injury_rhoave_BAYENV,
       y=results_pine3$Eref_rhoave, 
       xlab= "FCI rho Bayenv", 
       ylab= "LAT rho Bayenv" , 
       nbin=100, xlim=c(-0.3,0.3), ylim=c(-0.3,0.3),
       x_sub=superdf$Fall_cold_injury_rhoave_BAYENV[num.var.raw.out>0], 
       y_sub=superdf$Eref_rhoave[num.var.raw.out>0],
       PE=0.26)


plot_2D.b(x=results_pine3$Fall_cold_injury_p_raw_rho,
       y=results_pine3$LAT_raw_rho, 
       xlab= "FCI rho raw", 
       ylab= "LAT rho raw" , 
       nbin=100, xlim=c(-1,1), ylim=c(-1,1),
       x_sub=superdf$Fall_cold_injury_p_raw_rho[num.var.raw.out>0], 
       y_sub=superdf$LAT_raw_rho[num.var.raw.out>0],
       PE=-0.42)


plot_2D.b(x=results_pine3$Fall_cold_injury_snp_effect,
       y=results_pine3$LAT_snp_effect_GCTA, 
       xlab= "FCI gcta", 
       ylab= "LAT gcta" , 
       nbin=100, xlim=NULL, ylim=NULL,
       x_sub=superdf$Fall_cold_injury_snp_effect[num.var.raw.out>0], 
       y_sub=superdf$LAT_snp_effect_GCTA[num.var.raw.out>0],
       PE=-0.42)

````

### Make some outlier plots for everything

```{r, eval=FALSE}
MakeOutlierPlot("Group1_EnvByPhenoBayenv1.pdf", Group1_logical, type="Bayenv")
MakeOutlierPlot("Group1_EnvByPhenoRaw1.pdf", Group1_logical, type="Raw", xlim=c(-1,1), ylim=c(-1,1))
```


### Group 2: Lat and Low-temp variables
```{r}
colnames(is.superdf)
Group2cols.superdf <- colnames(is.superdf) %in% c(
                                          "LAT_raw_rho",
                                          "DD_0_raw_rho")

 ### Dataframe of Group 2
  Group2_allSuperSNPs <- superdf[rowSums(is.superdf[,Group2cols.superdf],na.rm = TRUE)>0,]
  
  ### Logical Group 2
  Group2_logical <- results_pine3$gcontig__gcontig_pos %in% Group2_allSuperSNPs$gcontig__gcontig_pos
  ## Check these two are equal
  nrow(Group2_allSuperSNPs)
  sum(Group2_logical)

  ### Group2 array for boostrap covariance
  Group2_allSuperSNPs_array_names <- unique(Group2_allSuperSNPs$gtcontig)
  Group2_allSuperSNPs_array <- sapply(Group2_allSuperSNPs_array_names, getInd2, Group2_allSuperSNPs)
  length(Group2_allSuperSNPs_array)
  
  #snps per contig
  Group2_df <- data.frame(contig=Group2_allSuperSNPs_array_names,
             numOutSnps=as.numeric(sapply(Group2_allSuperSNPs_array, length)))
  dim(Group2_df)
  Group2_df$rank_numOut <- rank(1/Group2_df$numOutSnps)
    # index shows order by number of SNPs - contig with most outlier SNPs # 1
  Group2_df$numTotSnps <- sapply(1:nrow(Group2_df), function(i){sum(results_pine3$gtcontig==Group2_df$contig[i])})
  Group2_df$prop <- Group2_df$numOutSnps/Group2_df$numTotSnps
    # proportion of outlier SNPs in that contig
  
  ### Print top candidate list to html file, ordered by the contigs with the higest proportion of outliers SNPS
  Group2_df$rank_prop <- rank(1/Group2_df$prop)
  Group2_df[order(Group2_df$prop, decreasing=TRUE),]
  
  ### Add column to results_pine3
  results_pine3$Group2_logical <- Group2_logical
```


### Designate small groups of focus variables
```{r}
xorder
envi_ind=c(2, 5, 6, 9, 10, 11, 12, 13, 17)
xorder[envi_ind]

yorder
pheno_ind=c(1,15, 16,17)
yorder[pheno_ind]

envi_ind_sm <- c(2,9,10)
xorder[envi_ind_sm]

pheno_ind_sm <- c(1,16)
yorder[pheno_ind_sm]

sum(Group2_logical & results_pine3$gtcontig=="comp60064_c0_seq1") 
#should equal 46
```

```{r, eval=FALSE}
### All 
MakeOutlierPlot("Group2_Lat_DD0_EnvByPhenoBayenv2.pdf", Group2_logical, type="Bayenv", envi_ind = envi_ind, pheno_ind=pheno_ind, width=20, height=24,
    Blue_logical=Group2_logical & results_pine3$gtcontig=="comp60064_c0_seq1",
    Green_logical= Group2_logical & results_pine3$gtcontig=="comp1563_c0_seq1",
    Golden_logical=Group2_logical & results_pine3$gtcontig=="comp73926_c0_seq1")

MakeOutlierPlot("Group2_Lat_DD0_EnvByPhenoRaw2.pdf", Group2_logical, type="Raw", envi_ind = envi_ind, pheno_ind=pheno_ind, width=20, height=24, xlim=c(-1,1), ylim=c(-1,1),
                    Blue_logical=Group2_logical & results_pine3$gtcontig=="comp60064_c0_seq1",
    Green_logical= Group2_logical & results_pine3$gtcontig=="comp1563_c0_seq1",
    Golden_logical=Group2_logical & results_pine3$gtcontig=="comp73926_c0_seq1")
```


### Group 3 CMD/MAP RAW outliers
```{r}
  Group3cols.superdf <- colnames(is.superdf) %in% c("CMD_raw_rho", "MAP_raw_rho")

 ### Dataframe of Group 3
  Group3_allSuperSNPs <- superdf[rowSums(is.superdf[,Group3cols.superdf],na.rm = TRUE)>0,]
   
  ### Logical Group 3
  Group3_logical <- results_pine3$gcontig__gcontig_pos %in% Group3_allSuperSNPs$gcontig__gcontig_pos
  ## Check these two are equal
  nrow(Group3_allSuperSNPs)
  sum(Group3_logical)

  ### Group3 array contigs
  Group3_allSuperSNPs_array_names <- unique(Group3_allSuperSNPs$gtcontig)
  Group3_allSuperSNPs_array <- sapply(Group3_allSuperSNPs_array_names, getInd2, Group3_allSuperSNPs)
  length(Group3_allSuperSNPs_array)
    # number of contigs in Group 3
  
  #snps per contig
  Group3_df <- data.frame(contig=Group3_allSuperSNPs_array_names,
             numOutSnps=as.numeric(sapply(Group3_allSuperSNPs_array, length)))
  #34 contigs
  
  dim(Group3_df)
  Group3_df$rank_numOut <- rank(1/Group3_df$numOutSnps)
    # index shows order by number of SNPs - contig with most outlier SNPs # 1
  Group3_df$numTotSnps <- sapply(1:nrow(Group3_df), function(i){sum(results_pine3$gtcontig==Group3_df$contig[i])})
  Group3_df$prop <- Group3_df$numOutSnps/Group3_df$numTotSnps
    # proportion of outlier SNPs in that contig
  
  ### Print top candidate list to html file, ordered by the contigs with the higest proportion of outliers SNPS
  Group3_df$rank_prop <- rank(1/Group3_df$prop)
  Group3_df[order(Group3_df$prop, decreasing=TRUE),]
  
  ### Add column to results_pine3
  results_pine3$Group3_logical <- Group3_logical
  
```


### Compare Group 2 and Group 3
```{r, eval=FALSE}
MakeOutlierPlot("Group2_vs_Group3_EnvByPhenoBayenv1.pdf", Group2_logical , type="Bayenv", envi_ind = envi_ind, pheno_ind=pheno_ind, width=20, height=24,
    Blue_logical=Group3_logical) 
MakeOutlierPlot("Group2_vs_Group3_EnvByPhenoBayenv_sm.pdf", Group2_logical , type="Bayenv", envi_ind = envi_ind_sm, pheno_ind=pheno_ind_sm, width=10, height=12,
    Blue_logical=Group3_logical) 

MakeOutlierPlot("Group2_vs_Group3_EnvByPhenoRaw1.pdf", Group2_logical, type="Raw", envi_ind = envi_ind, pheno_ind=pheno_ind, width=20, height=24, xlim=c(-1,1), ylim=c(-1,1),
    Blue_logical=Group3_logical)
MakeOutlierPlot("Group2_vs_Group3_EnvByPhenoRaw1_sm.pdf", Group2_logical, type="Raw", envi_ind = envi_ind_sm, pheno_ind=pheno_ind_sm, width=10, height=12, xlim=c(-1,1), ylim=c(-1,1),
    Blue_logical=Group3_logical)

MakeOutlierPlot("Group1sm_EnvByPhenoBayenv1.pdf", Group1_logical , type="Bayenv", envi_ind = envi_ind_sm, pheno_ind=pheno_ind_sm, width=10, height=12) 

MakeOutlierPlot("Group1sm_EnvByPhenoRaw1.pdf", Group1_logical, type="Raw", envi_ind = envi_ind_sm, pheno_ind=pheno_ind_sm, width=10, height=12, xlim=c(-1,1), ylim=c(-1,1))
```

```{r}
x=results_pine3$root_wt_shoot_wt_1_rhoave_BAYENV 
  # Total weight (ratio is without 1)
y=results_pine3$Fall_cold_injury_rhoave_BAYENV
par(mar=c(4,4,1,1))
plot_2D.b(x,y,xlab="Total weight", ylab="FCI", 
                      xlim=c(-0.3,0.3), 
                      ylim=c(-0.3,0.3), 
                      nbin=100, 
                      x_sub=x[Group2_logical], 
                      y_sub=y[Group2_logical],
                      x_sub_blue=x[Group3_logical], 
                      y_sub_blue=y[Group3_logical],
                      PE=-1)

# other outliers that aren't in the two groups
plot_2D.b(x,y,xlab="Total Weight", ylab="FCI", 
                      xlim=c(-0.3,0.3), 
                      ylim=c(-0.3,0.3), 
                      nbin=100, 
                      x_sub=x[Group1_logical & !Group2_logical & !Group3_logical], 
                      y_sub=y[Group1_logical & !Group2_logical & !Group3_logical],
                      PE=-1)

x=results_pine3$root_wt_shoot_wt_p_1_raw_rho 
y=results_pine3$Fall_cold_injury_p_raw_rho
plot_2D.b(x,y,xlab="Total weight", ylab="FCI", 
                      xlim=c(-1,1), 
                      ylim=c(-1,1), 
                      nbin=100, 
                      x_sub=x[Group2_logical], 
                      y_sub=y[Group2_logical],
                      x_sub_blue=x[Group3_logical], 
                      y_sub_blue=y[Group3_logical],
                      PE=-1)
plot_2D.b(x,y,xlab="Total weight", ylab="FCI", 
                      xlim=c(-1,1), 
                      ylim=c(-1,1), 
                      nbin=100, 
                      x_sub=x[Group1_logical & !Group2_logical & !Group3_logical], 
                      y_sub=y[Group1_logical & !Group2_logical & !Group3_logical], 
                      PE=-1)
```


### Make outlier plots - one for each candidate gene
This takes a while. To run this code, set MakeThesePlots <- TRUE below
```{r, eval=FALSE, fig.width=12}
MakeThesePlots <- FALSE
if(MakeThesePlots){
 ### Loop through top genes but for subset of envi
  for (i in 1:length(topcan)){
    magLogical <- results_pine3$gtcontig==topcan[i] & Group1_logical #outlier SNPs
    blueLogical <- results_pine3$gtcontig==topcan[i] & !Group1_logical #other SNPs in the gene
    nameBay <- paste(round(G1_df$prop[G1_df$contig==topcan[i]],2),
                     G1_df$numOutSnps[G1_df$contig==topcan[i]], 
                     G1_df$numTotSnps[G1_df$contig==topcan[i]],
                     topcan[i], "BayenvSub.pdf", sep="_")
    nameRaw <- paste(round(G1_df$prop[G1_df$contig==topcan[i]],2),
                     G1_df$numOutSnps[G1_df$contig==topcan[i]], 
                     G1_df$numTotSnps[G1_df$contig==topcan[i]],
                     topcan[i], "RawSub.pdf", sep="_")
    MakeOutlierPlot(nameBay, magLogical, type="Bayenv", Blue_logical = blueLogical,envi_ind = envi_ind_sm, pheno_ind=pheno_ind_sm, width=10, height=12)
    MakeOutlierPlot(nameRaw, magLogical, type="Raw", Blue_logical = blueLogical, xlim=c(-1,1), ylim=c(-1,1), envi_ind = envi_ind_sm, pheno_ind=pheno_ind_sm, width=10, height=12)
    print(c("done with", i, "of", length(topcan)))
  } #end for loop
}# end if
```

```{r, eval=FALSE}
write.table(G1_df, "../PineTopCandidates.txt", col.names=TRUE, row.names=FALSE)
G1_df

### 
```

### Merge G1_df with Kay's annotations
```{r}
go <- read.table("../GOanalysis/tair_pine_katie2", header=TRUE)
names(go)
names(G1_df)
names(go)[1] <- "contig2"
head(go$contig2)
head(G1_df$contig)
### Remove seq1, but check "seq1" in all rows first
length(grep("_seq1", G1_df$contig))==nrow(G1_df)

G1_df$contig2 <- sub("_seq1", "", G1_df$contig)
G1_df_go <- merge(G1_df, go, all=TRUE)
head(G1_df_go, 1)
tail(G1_df_go, 1)
nrow(G1_df_go) # should equal 107
write.table(G1_df_go, "../PineTopCandidates_WithGO.txt", col.names=TRUE, row.names=FALSE)
```

```{r, label="Plot MAT vs MAP"}
ff <- read.table ("../data/MAT06-BLUEs&Climate-pine.csv", sep = ",", header = T)
head(ff)
PE_MAT_MAP = cor(ff$MAT, ff$log.MAP.,use = "pairwise.complete.obs")
par(mar=c(4,4,1,1))
plot_2D.b(results_pine3$MAT_rhoave, results_pine3$MAP_rhoave, "Mean Annual Temperature", "Mean Annual Precipitation", nbin=100, x_sub=results_pine3$MAT_rhoave[Group2_logical], y_sub=results_pine3$MAP_rhoave[Group2_logical], x_sub_blue = results_pine3$MAT_rhoave[Group3_logical], y_sub_blue=results_pine3$MAP_rhoave[Group3_logical], PE = round(PE_MAT_MAP,2))
```

### Save .Rdata for further analysis (optional)
```{r}
save=FALSE
if (save==TRUE){
  out <- "../data/large_files/Pine_Alpha_AveRho_WithSuperLogical_OutputPEGA_2FindOutlierGroups.RData"
  save.image(file=out)
}

load=FALSE
if (load==TRUE){
  load(out)
}
```
Note that saving the image in this way uses a lot of unneccesary hard drive space.

### Summary of what was done so far:
- took Sam's list of super outliers - genes that have more outlier snps than predicted by random based on raw or corrected correlations at p9 level
- reduced list further to genes with SNPs in > 0.999 on raw rho (Group 1)
- I noticed two groups of behavior.  Chose variables that had strongest PE associations.
  - Group temp: subset of Group 1 that are raw outliers in LAT and DD0
  - Group moisture: subset of Group 1 that are raw outliers in MAP and CMD

### Next steps: assess significance
- Compare: Group 2 vs. random match set; Group 3 vs. random match set; other super SNPs in Group 1 but not in groups 2 or 3.
- Loop through pairs of variables

Function ()
  Loop over SNPs:
  - make a focal df and a dummy df for all data
  - Sample a SNP from the focal group and store
  - Sample a matching SNP by allele frequency from the dataset and store
  - reduce the focal df and dummy df by removing all SNPs in the gtcontig associated with     focal SNPs
  End loop
  return covariances for focal group and null group
End function

replicate or mapply function 1000 times
calculate 95% quantiles
paired t-test

```{r}
### Part 1: Get the right columns

p.bob <- PE_matchGWAS$Phenotype_GWAS[match(yorder[pheno_ind], PE_matchGWAS$Abb)]
  #because nothing was standardized, need to adjust names
(p.bob1 <- gsub("__", "_", p.bob))
(gpa2<- gsub("_p","",p.bob1))

(phen_names <- yorder[pheno_ind])
(pheno_bayenv_cols <- match(paste(gpa2, "_rhoave_BAYENV", sep=""), names(results_pine3)))
(pheno_raw_cols <-  match(paste(p.bob1,"_raw_rho", sep=""), names(results_pine3)))
## check
phen_df <- data.frame(name=phen_names, 
           bayenv_name=names(results_pine3)[pheno_bayenv_cols],
           raw_name=names(results_pine3)[pheno_raw_cols],
           bayenv_col=pheno_bayenv_cols,
           raw_col=pheno_raw_cols)
phen_df <- phen_df[c(3,2,4,1),] #reorder for analysis
phen_df

(env_names <- xorder[envi_ind])
(env_bayenv_cols <- match( paste(xorder[envi_ind],"_rhoave", sep=""), names(results_pine3)))
(env_raw_cols <-  match( paste(xorder[envi_ind],"_raw_rho", sep=""), names(results_pine3)))
## unit test
env_df <- data.frame(name=env_names, 
                     bayenv_name=names(results_pine3)[env_bayenv_cols],
                     raw_name=names(results_pine3)[env_raw_cols],
                     bayenv_col=env_bayenv_cols,
                     raw_col=env_raw_cols)
env_df

### final dataframe
final_df <- rbind(phen_df, env_df)
final_df

MakeOutlierPlot_with_stat <- function(filename, Group_logical, whichvars,
                                      #envi_ind=1:22, pheno_ind=c(1:3,5:17),
                                      xlim=c(-0.3,0.3), ylim=c(-0.3,0.3),  width=50, height=66, type="Bayenv", Green_logical=NULL, Blue_logical=NULL, Golden_logical=NULL){
    #type = "Bayenv" or "Raw"
  
  pdf(file = filename,width=width,height=height)
  par(mfrow=c(length(envi_ind),length(pheno_ind)), mar=c(2,2,0,0), oma=c(6,6,6,0))
  
  if(type=="Bayenv"){colz=final_df$bayenv_col}
  if(type=="Raw"){colz=final_df$raw_col}
  # test_set <- results_pine3$Group2_logical
  info1 <- results_pine3[,c("minor_freq","gtcontig", "pos_gcontig")]
  # head(info1)
  
  for (i in 1:(nrow(final_df)-1)){
    for (j in (i+1):nrow(final_df)){
        x1 <- results_pine3[,colz[i]]
        y1 <- results_pine3[,colz[j]]
        x1_test <- results_pine3[test_set,colz[i]]
        y1_test <- results_pine3[test_set,colz[j]]
        info1_test <- info[test_set,]
        
        ncontigs <- length(table(info_test$gtcontig))
        
        snp_mat <- matrix(NA, nrow= ncontigs, ncol=2)
          # 1st column match SNP x
          # 2nd column match SNP y

      GetSampleCov <- function(){
        info <- data.frame(info1, x1, y1)
        info_test <- data.frame(info1_test, x1_test, y1_test)
        # REASSIGNMENT HERE TO REMOVE ALL SNPS FROM THE 
        # SAME CONTIG EVERY TIME A SNP IS CHOSEN FOR THE NEXT STEP
        ### sample test SNPs
        rand_test_set <- info_test %>% group_by(gtcontig) %>% sample_n(size = 1)
        ### unit test
        if(length(unique(info_test$gtcontig)) != nrow(rand_test_set)){
          print("Error")
          break
        } #end if 
        test_cov <- cov(rand_test_set$x1_test, rand_test_set$y1_test)
        
          #get matching SNPs
        for (k in 1:nrow(rand_test_set)){
          test_maf <- rand_test_set$minor_freq[k]
          b <- info %>% filter((minor_freq < (test_maf+0.025)) & (minor_freq > test_maf-0.025)) %>% sample_n(size = 1)
          snp_mat[k,] <- c(b$x1, b$y1)
          # could update info here by removing columns with gtcontig in b
          info <- info %>% filter(gtcontig!=b$gtcontig)
            # this line of code slows down 2x
        }
          ### SLOW WAY
          # match_logic <- (info$minor_freq < test_maf+0.025) &
          #   (info$minor_freq > test_maf-0.025) 
          #     #~50000 SNPs for minimum and 25,000 SNPs for maximum. think we're OK
          #     # match within MAF 0.05 window centered on test SNP
          # info_sub <- info[match_logic,]
          # match_index <- sample(1:nrow(info_sub),1)
          # snp_mat[k,] <- c(info_sub$x1[match_index], info_sub$y1[match_index])
          # ind_to_remove <- which(info$gtcontig==info_sub[match_index,]$gtcontig)
          # info <- info[-ind_to_remove,]
        }

        null_cov <- cov(snp_mat[,1], snp_mat[,2])
        return(c(test_cov=test_cov, null_cov=null_cov))
      }
      
      compare <-  data.frame(t(replicate(100, GetSampleCov())))
        #~12 sec per 10 replicates
        # 
      plot(density(compare$test_cov))
      points(density(compare$null_cov))
      
      quantile(compare$test_cov, 0.05)  
      quantile(compare$null_cov, 0.95)
      
      t.test(compare$test_cov, compare$null_cov ,paired = TRUE)
      
      #TO DO RED AND BLUE GROUPS
        
      # make plot2D
      plot_2D.b(x,y, 
         xlab= "", xlim=xlim,
         ylab= "" , ylim=ylim,
         nbin=100, 
         x_sub=x[Group_logical], 
         y_sub=y[Group_logical],
         PE=pecorr,
         x_sub_green=x[Green_logical],
         y_sub_green=y[Green_logical],
         x_sub_blue=x[Blue_logical],
         y_sub_blue=y[Blue_logical],
         x_sub_golden=x[Golden_logical],
         y_sub_golden=y[Golden_logical]
         ) 
      mtext(xorder[i], side=2)
      mtext(yorder[j], side=1)
    } #end j loop
    print(i)
    } #end i loop
  dev.off()

}# end function
```